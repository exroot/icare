{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport axios from \"axios\";\n\nconst fetcher = async url => {\n  const token = localStorage.getItem(\"access\");\n  const clientInstance = axios.create({\n    headers: _objectSpread({\n      Accept: \"application/json\"\n    }, token ? {\n      Authorization: `Bearer ${token}`\n    } : {}),\n    baseURL: process.env.NEXT_PUBLIC_API_URL\n  });\n\n  try {\n    clientInstance.interceptors.response.use( // RESPONSE\n    async response => {\n      if (!localStorage.getItem(\"access\") && response.data.is_logged_in === false) {\n        return Promise.resolve(response);\n      }\n\n      if (localStorage.getItem(\"access\") && response.data.is_logged_in === true) {\n        return Promise.resolve(response);\n      } // Try request again but with a new access token\n      // wait for a new access token\n\n\n      const refresh = {\n        refresh: localStorage.getItem(\"refresh\")\n      };\n      const {\n        data: token\n      } = await axios.post(\"/auth/token/refresh/\", refresh, {\n        /* Enable cookies to send the refresh token */\n        // withCredentials: true,\n        baseURL: process.env.NEXT_PUBLIC_API_URL\n      });\n      localStorage.setItem(\"access\", token.access); // New request with new token\n\n      const {\n        config\n      } = response;\n      config.headers.Authorization = `Bearer ${localStorage.getItem(\"access\")}`;\n      const newResponse = await axios.request(_objectSpread(_objectSpread({}, config), {}, {\n        method: \"GET\"\n      }));\n      return Promise.resolve(newResponse);\n    }, // ERROR\n    async error => {\n      var _error$response;\n\n      // Return any error which is not due to authentication normally\n      if (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) !== 401) {\n        return Promise.reject(error);\n      }\n      /* \n        status 401 on refresh_token endpoint => Logout user because refresh token didn't work\n        \n        Also, redirect to login page \n      */\n\n\n      if (error.config.url === \"/auth/token/refresh/\") {\n        return Promise.resolve({\n          is_logged_in: false\n        });\n      } // Try request again but with a new access token\n      // wait for a new access token\n\n\n      const refresh = {\n        refresh: localStorage.getItem(\"refresh\")\n      };\n      const {\n        data: token\n      } = await axios.post(\"/auth/token/refresh/\", refresh, {\n        /* Enable cookies to send the refresh token */\n        // withCredentials: true,\n        baseURL: process.env.NEXT_PUBLIC_API_URL\n      });\n      localStorage.setItem(\"access\", token.access); // New request with new token\n\n      const {\n        config\n      } = error;\n      config.headers.Authorization = `Bearer ${localStorage.getItem(\"access\")}`;\n      const response = await axios.request(_objectSpread(_objectSpread({}, config), {}, {\n        method: \"GET\"\n      }));\n      return Promise.resolve(response);\n    });\n    const {\n      data\n    } = await clientInstance.get(url);\n    return data;\n  } catch (err) {\n    //   Refresh token has expired or something happened\n    return Promise.resolve({\n      is_logged_in: false\n    }); // throw err;\n  }\n};\n\nexport default fetcher;","map":{"version":3,"sources":["/home/binaural14/projects/personal/icare/lib/fetcher.js"],"names":["axios","fetcher","url","token","localStorage","getItem","clientInstance","create","headers","Accept","Authorization","baseURL","process","env","NEXT_PUBLIC_API_URL","interceptors","response","use","data","is_logged_in","Promise","resolve","refresh","post","setItem","access","config","newResponse","request","method","error","status","reject","get","err"],"mappings":"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","sourcesContent":["import axios from \"axios\";\n\nconst fetcher = async (url) => {\n  const token = localStorage.getItem(\"access\");\n  const clientInstance = axios.create({\n    headers: {\n      Accept: \"application/json\",\n      ...(token ? { Authorization: `Bearer ${token}` } : {}),\n    },\n    baseURL: process.env.NEXT_PUBLIC_API_URL,\n  });\n\n  try {\n    clientInstance.interceptors.response.use(\n      // RESPONSE\n      async (response) => {\n        if (\n          !localStorage.getItem(\"access\") &&\n          response.data.is_logged_in === false\n        ) {\n          return Promise.resolve(response);\n        }\n        if (\n          localStorage.getItem(\"access\") &&\n          response.data.is_logged_in === true\n        ) {\n          return Promise.resolve(response);\n        }\n        // Try request again but with a new access token\n        // wait for a new access token\n        const refresh = { refresh: localStorage.getItem(\"refresh\") };\n        const { data: token } = await axios.post(\n          \"/auth/token/refresh/\",\n          refresh,\n          {\n            /* Enable cookies to send the refresh token */\n            // withCredentials: true,\n            baseURL: process.env.NEXT_PUBLIC_API_URL,\n          }\n        );\n        localStorage.setItem(\"access\", token.access);\n        // New request with new token\n        const {config} = response;\n        config.headers.Authorization = `Bearer ${localStorage.getItem(\n          \"access\"\n        )}`;\n        const newResponse = await axios.request({\n          ...config,\n          method: \"GET\",\n        });\n        return Promise.resolve(newResponse);\n      },\n      // ERROR\n      async (error) => {\n        // Return any error which is not due to authentication normally\n        if (error.response?.status !== 401) {\n          return Promise.reject(error);\n        }\n        /* \n          status 401 on refresh_token endpoint => Logout user because refresh token didn't work\n          \n          Also, redirect to login page \n      */\n\n        if (error.config.url === \"/auth/token/refresh/\") {\n          return Promise.resolve({\n            is_logged_in: false,\n          });\n        }\n        // Try request again but with a new access token\n        // wait for a new access token\n        const refresh = { refresh: localStorage.getItem(\"refresh\") };\n        const { data: token } = await axios.post(\n          \"/auth/token/refresh/\",\n          refresh,\n          {\n            /* Enable cookies to send the refresh token */\n            // withCredentials: true,\n            baseURL: process.env.NEXT_PUBLIC_API_URL,\n          }\n        );\n        localStorage.setItem(\"access\", token.access);\n        // New request with new token\n        const {config} = error;\n        config.headers.Authorization = `Bearer ${localStorage.getItem(\n          \"access\"\n        )}`;\n        const response = await axios.request({\n          ...config,\n          method: \"GET\",\n        });\n        return Promise.resolve(response);\n      }\n    );\n    const { data } = await clientInstance.get(url);\n    return data;\n  } catch (err) {\n    //   Refresh token has expired or something happened\n    return Promise.resolve({\n      is_logged_in: false,\n    });\n\n    // throw err;\n  }\n};\n\nexport default fetcher;\n"]},"metadata":{},"sourceType":"module"}